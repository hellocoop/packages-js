/**
 * HTTP Message Signature fetch implementation
 */

import {
    HttpSigFetchOptions,
    VALID_DERIVED_COMPONENTS,
    DEFAULT_COMPONENTS_GET,
    DEFAULT_COMPONENTS_BODY,
} from './types.js'
import {
    importPrivateKey,
    getPublicJwk,
    sign as cryptoSign,
    getAlgorithmFromJwk,
    validateJwk,
} from './utils/crypto.js'
import {
    generateSignatureBase,
    generateSignatureInputHeader,
    generateSignatureKeyHeader,
    generateSignatureHeader,
    generateContentDigest,
} from './utils/signature.js'

/**
 * Determine content-type from body type, matching standard fetch behavior
 */
function getContentTypeFromBody(body: any): string | null {
    if (body === null || body === undefined) {
        return null
    }

    // URLSearchParams
    if (body instanceof URLSearchParams) {
        return 'application/x-www-form-urlencoded;charset=UTF-8'
    }

    // FormData
    if (typeof FormData !== 'undefined' && body instanceof FormData) {
        // FormData gets a multipart/form-data with boundary
        // The boundary is generated by the fetch implementation
        // We can't set this ourselves, so return null to let fetch handle it
        return null
    }

    // Blob or File
    if (typeof Blob !== 'undefined' && body instanceof Blob) {
        return body.type || 'application/octet-stream'
    }

    // String (including JSON.stringify results)
    if (typeof body === 'string') {
        return 'text/plain;charset=UTF-8'
    }

    // ArrayBuffer, TypedArray, DataView, ReadableStream
    // Default to application/octet-stream for binary data
    return 'application/octet-stream'
}

/**
 * Validate component names
 */
function validateComponents(components: string[], headers: Headers): void {
    for (const component of components) {
        // Skip special components that we add
        if (
            component === '@signature-params' ||
            component === 'signature-key' ||
            component === 'signature-input' ||
            component === 'signature'
        ) {
            continue
        }

        // Check if it's a valid derived component
        if (component.startsWith('@')) {
            if (!VALID_DERIVED_COMPONENTS.includes(component as any)) {
                throw new Error(`Invalid derived component: ${component}`)
            }
        } else {
            // For header components, verify the header exists
            if (!headers.has(component)) {
                throw new Error(
                    `Component "${component}" specified but header not found in request`,
                )
            }
        }
    }
}

/**
 * Signed fetch - wraps standard fetch with HTTP Message Signatures
 */
export async function fetch(
    url: string | URL,
    options: HttpSigFetchOptions,
): Promise<Response | { headers: Headers }> {
    const {
        signingKey,
        signatureKey,
        label = 'sig',
        components: customComponents,
        dryRun = false,
        method = 'GET',
        headers: inputHeaders = {},
        body,
        ...fetchOptions
    } = options

    // Validate signing key
    validateJwk(signingKey)

    // Import private key
    const privateKey = await importPrivateKey(signingKey)
    const algorithm = getAlgorithmFromJwk(signingKey)

    // Get public key for hwk type
    const publicJwk = getPublicJwk(signingKey)

    // Parse URL
    const urlObj = typeof url === 'string' ? new URL(url) : url
    const targetUri = urlObj.href

    // Prepare headers (need this before determining components)
    const headers = new Headers(inputHeaders)

    // Determine covered components
    let components: string[]
    if (customComponents) {
        // Deduplicate components
        components = [...new Set(customComponents)]
    } else {
        // Use defaults based on whether there's a body
        const hasBody = body !== undefined && body !== null
        components = hasBody
            ? [...DEFAULT_COMPONENTS_BODY]
            : [...DEFAULT_COMPONENTS_GET]
    }

    const componentValues = new Map<string, string>()

    // Handle body-related headers if body exists
    if (body !== undefined && body !== null) {
        // Add content-type if not already set, matching standard fetch behavior
        if (!headers.has('content-type')) {
            const autoContentType = getContentTypeFromBody(body)
            if (autoContentType !== null) {
                headers.set('content-type', autoContentType)
            }
        }

        // Generate content-digest if component list includes it
        if (components.includes('content-digest')) {
            const contentDigest = await generateContentDigest(body)
            headers.set('content-digest', contentDigest)
        }
    }

    // Generate Signature-Key header if component list includes it
    if (components.includes('signature-key')) {
        const signatureKeyHeader = generateSignatureKeyHeader(
            label,
            signatureKey,
            publicJwk,
        )
        headers.set('signature-key', signatureKeyHeader)
    }

    // Validate components before building values
    validateComponents(components, headers)

    // Build component values for all specified components
    for (const component of components) {
        if (component.startsWith('@')) {
            // Derived components
            switch (component) {
                case '@method':
                    componentValues.set('@method', method.toUpperCase())
                    break
                case '@target-uri':
                    componentValues.set('@target-uri', targetUri)
                    break
                case '@authority':
                    componentValues.set('@authority', urlObj.host)
                    break
                case '@scheme':
                    componentValues.set(
                        '@scheme',
                        urlObj.protocol.replace(':', ''),
                    )
                    break
                case '@request-target':
                    componentValues.set(
                        '@request-target',
                        `${urlObj.pathname}${urlObj.search}`,
                    )
                    break
                case '@path':
                    componentValues.set('@path', urlObj.pathname)
                    break
                case '@query':
                    componentValues.set(
                        '@query',
                        urlObj.search ? urlObj.search.substring(1) : '',
                    )
                    break
                default:
                    throw new Error(
                        `Unsupported derived component: ${component}`,
                    )
            }
        } else {
            // Header components - get from headers
            const value = headers.get(component)
            if (value !== null) {
                componentValues.set(component, value)
            }
        }
    }

    // Generate timestamp
    const created = Math.floor(Date.now() / 1000)

    // Generate Signature-Input header
    const signatureInputHeader = generateSignatureInputHeader(
        label,
        components,
        created,
    )
    headers.set('signature-input', signatureInputHeader)

    // Add signature params to component values
    const componentList = components.map((c) => `"${c}"`).join(' ')
    const signatureParams = `(${componentList});created=${created}`
    componentValues.set('@signature-params', signatureParams)
    components.push('@signature-params')

    // Generate signature base
    const signatureBase = generateSignatureBase(components, componentValues)
    const signatureBaseBytes = new TextEncoder().encode(signatureBase)

    // Sign the signature base
    const signature = await cryptoSign(
        signatureBaseBytes,
        privateKey,
        algorithm,
    )

    // Generate Signature header
    const signatureHeader = generateSignatureHeader(label, signature)
    headers.set('signature', signatureHeader)

    // If dryRun, return headers only
    if (dryRun) {
        return { headers }
    }

    // Make the actual fetch request
    return globalThis.fetch(urlObj, {
        ...fetchOptions,
        method,
        headers,
        body,
    })
}
